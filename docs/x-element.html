<!DOCTYPE html>

<html>
<head>
  <title>x-element.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>x-element.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">import</span> { asyncAppend } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../lit-html/directives/async-append.js&#x27;</span>;
<span class="hljs-keyword">import</span> { asyncReplace } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../lit-html/directives/async-replace.js&#x27;</span>;
<span class="hljs-keyword">import</span> { cache } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../lit-html/directives/cache.js&#x27;</span>;
<span class="hljs-keyword">import</span> { classMap } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../lit-html/directives/class-map.js&#x27;</span>;
<span class="hljs-keyword">import</span> { directive, html, render, svg } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../lit-html/lit-html.js&#x27;</span>;
<span class="hljs-keyword">import</span> { guard } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../lit-html/directives/guard.js&#x27;</span>;
<span class="hljs-keyword">import</span> { ifDefined } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../lit-html/directives/if-defined.js&#x27;</span>;
<span class="hljs-keyword">import</span> { live } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../lit-html/directives/live.js&#x27;</span>;
<span class="hljs-keyword">import</span> { repeat } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../lit-html/directives/repeat.js&#x27;</span>;
<span class="hljs-keyword">import</span> { styleMap } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../lit-html/directives/style-map.js&#x27;</span>;
<span class="hljs-keyword">import</span> { templateContent } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../lit-html/directives/template-content.js&#x27;</span>;
<span class="hljs-keyword">import</span> { unsafeHTML } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../lit-html/directives/unsafe-html.js&#x27;</span>;
<span class="hljs-keyword">import</span> { unsafeSVG } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../lit-html/directives/unsafe-svg.js&#x27;</span>;
<span class="hljs-keyword">import</span> { until } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../lit-html/directives/until.js&#x27;</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>TODO: replace “__thing &gt;&gt; #thing” when static private fields are supported.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XElement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLElement</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>All declared properties are observed via associated attributes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> <span class="hljs-title">observedAttributes</span>() {
    XElement.__analyzeConstructor(<span class="hljs-built_in">this</span>);
    <span class="hljs-keyword">const</span> { attributeMap } = XElement.__constructors.get(<span class="hljs-built_in">this</span>);
    <span class="hljs-keyword">return</span> [...attributeMap.keys()];
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>This gets converted into “propertyMap” and “attributeMap” internally.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> <span class="hljs-title">properties</span>() {
    <span class="hljs-keyword">return</span> {};
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>This gets converted into “listenerMap” internally.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> <span class="hljs-title">listeners</span>() {
    <span class="hljs-keyword">return</span> {};
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Typically, you want a shadow root, but “host” could also be returned.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">static</span> createRenderRoot(host) {
    <span class="hljs-keyword">return</span> host.attachShadow({ <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;open&#x27;</span> });
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Use the current property values to interpolate an html template.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">static</span> template(html, engine) { <span class="hljs-comment">// eslint-disable-line no-unused-vars, no-shadow</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">properties, host</span>) =&gt;</span> {}; <span class="hljs-comment">// eslint-disable-line no-unused-vars</span>
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Standard instance constructor.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">constructor</span>() {
    <span class="hljs-built_in">super</span>();
    XElement.__constructHost(<span class="hljs-built_in">this</span>);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Standard HTMLElement connectedCallback.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  connectedCallback() {
    XElement.__initializeHost(<span class="hljs-built_in">this</span>);
    XElement.__addListeners(<span class="hljs-built_in">this</span>);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Standard HTMLElement attributeChangedCallback.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  attributeChangedCallback(attribute, oldValue, value) {
    <span class="hljs-keyword">const</span> { attributeMap } = XElement.__constructors.get(<span class="hljs-built_in">this</span>.constructor);
    attributeMap.get(attribute).sync(<span class="hljs-built_in">this</span>, value, oldValue);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Standard HTMLElement adoptedCallback.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  adoptedCallback() {}</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Standard HTMLElement disconnectedCallback.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  disconnectedCallback() {
    XElement.__removeListeners(<span class="hljs-built_in">this</span>);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Bind template result to render root.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  render() {
    <span class="hljs-keyword">const</span> { template, properties, renderRoot } = XElement.__hosts.get(<span class="hljs-built_in">this</span>);
    render(template(properties, <span class="hljs-built_in">this</span>), renderRoot);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Convenience wrapper around addEventListener to get the “this” right.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  listen(element, type, callback, options) {
    <span class="hljs-keyword">if</span> (XElement.__typeIsWrong(EventTarget, element)) {
      <span class="hljs-keyword">const</span> typeName = XElement.__getTypeName(element);
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unexpected element passed to listen (expected EventTarget, got <span class="hljs-subst">${typeName}</span>).`</span>);
    }
    <span class="hljs-keyword">if</span> (XElement.__typeIsWrong(<span class="hljs-built_in">String</span>, type)) {
      <span class="hljs-keyword">const</span> typeName = XElement.__getTypeName(type);
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unexpected type passed to listen (expected String, got <span class="hljs-subst">${typeName}</span>).`</span>);
    }
    <span class="hljs-keyword">if</span> (XElement.__typeIsWrong(<span class="hljs-built_in">Function</span>, callback)) {
      <span class="hljs-keyword">const</span> typeName = XElement.__getTypeName(callback);
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unexpected callback passed to listen (expected Function, got <span class="hljs-subst">${typeName}</span>).`</span>);
    }
    <span class="hljs-keyword">if</span> (XElement.__notNullish(options) &amp;&amp; XElement.__typeIsWrong(<span class="hljs-built_in">Object</span>, options)) {
      <span class="hljs-keyword">const</span> typeName = XElement.__getTypeName(options);
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unexpected options passed to listen (expected Object, got <span class="hljs-subst">${typeName}</span>).`</span>);
    }
    XElement.__addListener(<span class="hljs-built_in">this</span>, element, type, callback, options);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Inverse of listen. Use this to make sure function pointer is the same.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  unlisten(element, type, callback, options) {
    <span class="hljs-keyword">if</span> (XElement.__typeIsWrong(EventTarget, element)) {
      <span class="hljs-keyword">const</span> typeName = XElement.__getTypeName(element);
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unexpected element passed to unlisten (expected EventTarget, got <span class="hljs-subst">${typeName}</span>).`</span>);
    }
    <span class="hljs-keyword">if</span> (XElement.__typeIsWrong(<span class="hljs-built_in">String</span>, type)) {
      <span class="hljs-keyword">const</span> typeName = XElement.__getTypeName(type);
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unexpected type passed to unlisten (expected String, got <span class="hljs-subst">${typeName}</span>).`</span>);
    }
    <span class="hljs-keyword">if</span> (XElement.__typeIsWrong(<span class="hljs-built_in">Function</span>, callback)) {
      <span class="hljs-keyword">const</span> typeName = XElement.__getTypeName(callback);
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unexpected callback passed to unlisten (expected Function, got <span class="hljs-subst">${typeName}</span>).`</span>);
    }
    <span class="hljs-keyword">if</span> (XElement.__notNullish(options) &amp;&amp; XElement.__typeIsWrong(<span class="hljs-built_in">Object</span>, options)) {
      <span class="hljs-keyword">const</span> typeName = XElement.__getTypeName(options);
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unexpected options passed to unlisten (expected Object, got <span class="hljs-subst">${typeName}</span>).`</span>);
    }
    XElement.__removeListener(<span class="hljs-built_in">this</span>, element, type, callback, options);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Dispatch a standard “ErrorEvent” on the element.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  dispatchError(error) {
    <span class="hljs-keyword">const</span> { message } = error;
    <span class="hljs-keyword">const</span> eventData = { error, message, <span class="hljs-attr">bubbles</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">composed</span>: <span class="hljs-literal">true</span> };
    <span class="hljs-built_in">this</span>.dispatchEvent(<span class="hljs-keyword">new</span> ErrorEvent(<span class="hljs-string">&#x27;error&#x27;</span>, eventData));
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>For element authors. Set and get “internal” properties.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">get</span> <span class="hljs-title">internal</span>() {
    <span class="hljs-keyword">return</span> XElement.__hosts.get(<span class="hljs-built_in">this</span>).internal;
  }

  <span class="hljs-keyword">static</span> __analyzeConstructor(<span class="hljs-keyword">constructor</span>) {
    <span class="hljs-keyword">const</span> { properties, listeners } = <span class="hljs-keyword">constructor</span>;
    const propertiesEntries = Object.entries(properties);
    const listenersEntries = Object.entries(listeners);
    XElement.__validateProperties(<span class="hljs-keyword">constructor</span>, properties, propertiesEntries);
    XElement.__validateListeners(<span class="hljs-keyword">constructor</span>, listeners, listenersEntries);
    const propertyMap = new Map(propertiesEntries);
    const internalPropertyMap = new Map();</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Use a normal object for better autocomplete when debugging in console.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">const</span> propertiesTarget = {};
    <span class="hljs-keyword">const</span> internalTarget = {};
    <span class="hljs-keyword">const</span> attributeMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, property] <span class="hljs-keyword">of</span> propertyMap) {</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>We mutate (vs copy) to allow cross-referencing property objects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      XElement.__mutateProperty(<span class="hljs-keyword">constructor</span>, propertyMap, key, property);
      if (property.internal || property.readOnly) {
        internalPropertyMap.set(key, property);
        internalTarget[key] = <span class="hljs-literal">undefined</span>;
      }
      propertiesTarget[key] = <span class="hljs-literal">undefined</span>;
      attributeMap.set(property.attribute, property);
    }
    <span class="hljs-keyword">const</span> listenerMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(listenersEntries);
    XElement.__constructors.set(<span class="hljs-keyword">constructor</span>, {
      propertyMap, internalPropertyMap, attributeMap, listenerMap,
      propertiesTarget, internalTarget,
    });
  }

  <span class="hljs-keyword">static</span> __validateProperties(<span class="hljs-keyword">constructor</span>, properties, entries) {
    <span class="hljs-keyword">const</span> path = <span class="hljs-string">`<span class="hljs-subst">${constructor.name}</span>.properties`</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, property] <span class="hljs-keyword">of</span> entries) {
      <span class="hljs-keyword">if</span> (XElement.__typeIsWrong(<span class="hljs-built_in">Object</span>, property)) {
        <span class="hljs-keyword">const</span> typeName = XElement.__getTypeName(property);
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`<span class="hljs-subst">${path}</span>.<span class="hljs-subst">${key}</span> has an unexpected value (expected Object, got <span class="hljs-subst">${typeName}</span>).`</span>);
      }
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, property] <span class="hljs-keyword">of</span> entries) {
      XElement.__validateProperty(<span class="hljs-keyword">constructor</span>, key, property);
    }
    const attributes = new Set();
    const inputMap = new Map();
    for (const [key, property] of entries) {
      <span class="hljs-keyword">const</span> attribute = property.attribute || XElement.__camelToKebab(key);
      <span class="hljs-keyword">if</span> (attributes.has(attribute)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`<span class="hljs-subst">${path}</span>.<span class="hljs-subst">${key}</span> causes a duplicated attribute &quot;<span class="hljs-subst">${attribute}</span>&quot;.`</span>);
      }
      attributes.add(attribute);
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Reflect</span>.has(property, <span class="hljs-string">&#x27;input&#x27;</span>)) {
        <span class="hljs-keyword">const</span> { input } = property;
        inputMap.set(property, input.map(<span class="hljs-function"><span class="hljs-params">inputKey</span> =&gt;</span> properties[inputKey]));
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [index, inputKey] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(input)) {
          <span class="hljs-keyword">if</span> (XElement.__typeIsWrong(<span class="hljs-built_in">Object</span>, properties[inputKey])) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`<span class="hljs-subst">${path}</span>.<span class="hljs-subst">${key}</span>.input[<span class="hljs-subst">${index}</span>] has an unexpected item (&quot;<span class="hljs-subst">${inputKey}</span>&quot; has not been declared).`</span>);
          }
        }
      }
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, property] <span class="hljs-keyword">of</span> entries) {
      <span class="hljs-keyword">if</span> (XElement.__propertyIsCyclic(property, inputMap)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`<span class="hljs-subst">${path}</span>.<span class="hljs-subst">${key}</span>.input is cyclic.`</span>);
      }
    }
  }

  <span class="hljs-keyword">static</span> __validateProperty(<span class="hljs-keyword">constructor</span>, key, property) {
    <span class="hljs-keyword">const</span> path = <span class="hljs-string">`<span class="hljs-subst">${constructor.name}</span>.properties.<span class="hljs-subst">${key}</span>`</span>;
    <span class="hljs-keyword">if</span> (X_ELEMENT_INTERFACE.has(key)) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unexpected key &quot;<span class="hljs-subst">${path}</span>&quot; shadows XElement.prototype interface (<span class="hljs-subst">${[...X_ELEMENT_INTERFACE].join(<span class="hljs-string">&#x27;, &#x27;</span>)}</span>).`</span>);
    }
    <span class="hljs-keyword">if</span> (INHERITED_INTERFACE.has(key)) {
      <span class="hljs-keyword">const</span> error = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unexpected key &quot;<span class="hljs-subst">${path}</span>&quot; shadows inherited property name, behavior not guaranteed.`</span>);
      <span class="hljs-built_in">console</span>.warn(error); <span class="hljs-comment">// eslint-disable-line no-console</span>
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> propertyKey <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.keys(property)) {
      <span class="hljs-keyword">if</span> (XElement.__propertyKeys.has(propertyKey) === <span class="hljs-literal">false</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unexpected key &quot;<span class="hljs-subst">${path}</span>.<span class="hljs-subst">${propertyKey}</span>&quot;.`</span>);
      }
    }
    <span class="hljs-keyword">const</span> { type, attribute, compute, input, reflect, internal, readOnly } = property;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Reflect</span>.has(property, <span class="hljs-string">&#x27;type&#x27;</span>) &amp;&amp; XElement.__typeIsWrong(<span class="hljs-built_in">Function</span>, type)) {
      <span class="hljs-keyword">const</span> typeName = XElement.__getTypeName(type);
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unexpected value for &quot;<span class="hljs-subst">${path}</span>.type&quot; (expected constructor Function, got <span class="hljs-subst">${typeName}</span>).`</span>);
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> subKey <span class="hljs-keyword">of</span> [<span class="hljs-string">&#x27;compute&#x27;</span>, <span class="hljs-string">&#x27;observe&#x27;</span>]) {
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Reflect</span>.has(property, subKey) &amp;&amp; XElement.__typeIsWrong(<span class="hljs-built_in">Function</span>, property[subKey])) {
        <span class="hljs-keyword">const</span> typeName = XElement.__getTypeName(property[subKey]);
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unexpected value for &quot;<span class="hljs-subst">${path}</span>.<span class="hljs-subst">${subKey}</span>&quot; (expected Function, got <span class="hljs-subst">${typeName}</span>).`</span>);
      }
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> subKey <span class="hljs-keyword">of</span> [<span class="hljs-string">&#x27;reflect&#x27;</span>, <span class="hljs-string">&#x27;internal&#x27;</span>, <span class="hljs-string">&#x27;readOnly&#x27;</span>]) {
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Reflect</span>.has(property, subKey) &amp;&amp; XElement.__typeIsWrong(<span class="hljs-built_in">Boolean</span>, property[subKey])) {
        <span class="hljs-keyword">const</span> typeName = XElement.__getTypeName(property[subKey]);
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unexpected value for &quot;<span class="hljs-subst">${path}</span>.<span class="hljs-subst">${subKey}</span>&quot; (expected Boolean, got <span class="hljs-subst">${typeName}</span>).`</span>);
      }
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Reflect</span>.has(property, <span class="hljs-string">&#x27;attribute&#x27;</span>) &amp;&amp; XElement.__typeIsWrong(<span class="hljs-built_in">String</span>, attribute)) {
      <span class="hljs-keyword">const</span> typeName = XElement.__getTypeName(attribute);
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unexpected value for &quot;<span class="hljs-subst">${path}</span>.attribute&quot; (expected String, got <span class="hljs-subst">${typeName}</span>).`</span>);
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Reflect</span>.has(property, <span class="hljs-string">&#x27;attribute&#x27;</span>) &amp;&amp; attribute === <span class="hljs-string">&#x27;&#x27;</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unexpected value for &quot;<span class="hljs-subst">${path}</span>.attribute&quot; (expected non-empty String).`</span>);
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> subKey <span class="hljs-keyword">of</span> [<span class="hljs-string">&#x27;initial&#x27;</span>, <span class="hljs-string">&#x27;default&#x27;</span>]) {
      <span class="hljs-keyword">const</span> value = <span class="hljs-built_in">Reflect</span>.get(property, subKey);
      <span class="hljs-keyword">if</span> (
        XElement.__notNullish(value) &amp;&amp;
        XElement.__typeIsWrong(<span class="hljs-built_in">Boolean</span>, value) &amp;&amp;
        XElement.__typeIsWrong(<span class="hljs-built_in">String</span>, value) &amp;&amp;
        XElement.__typeIsWrong(<span class="hljs-built_in">Number</span>, value) &amp;&amp;
        XElement.__typeIsWrong(<span class="hljs-built_in">Function</span>, value)
      ) {
        <span class="hljs-keyword">const</span> typeName = XElement.__getTypeName(value);
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unexpected value for &quot;<span class="hljs-subst">${path}</span>.<span class="hljs-subst">${subKey}</span>&quot; (expected Boolean, String, Number, or Function, got <span class="hljs-subst">${typeName}</span>).`</span>);
      }
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Reflect</span>.has(property, <span class="hljs-string">&#x27;input&#x27;</span>) &amp;&amp; XElement.__typeIsWrong(<span class="hljs-built_in">Array</span>, input)) {
      <span class="hljs-keyword">const</span> typeName = XElement.__getTypeName(input);
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unexpected value for &quot;<span class="hljs-subst">${path}</span>.input&quot; (expected Array, got <span class="hljs-subst">${typeName}</span>).`</span>);
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Reflect</span>.has(property, <span class="hljs-string">&#x27;input&#x27;</span>)) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [index, inputKey] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(input)) {
        <span class="hljs-keyword">if</span> (XElement.__typeIsWrong(<span class="hljs-built_in">String</span>, inputKey)) {
          <span class="hljs-keyword">const</span> typeName = XElement.__getTypeName(inputKey);
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unexpected value for &quot;<span class="hljs-subst">${path}</span>.input[<span class="hljs-subst">${index}</span>]&quot; (expected String, got <span class="hljs-subst">${typeName}</span>).`</span>);
        }
      }
    }
    <span class="hljs-keyword">if</span> (reflect &amp;&amp; (<span class="hljs-built_in">Reflect</span>.has(property, <span class="hljs-string">&#x27;type&#x27;</span>) === <span class="hljs-literal">false</span> || XElement.__serializableTypes.has(property.type) === <span class="hljs-literal">false</span>)) {
      <span class="hljs-keyword">const</span> typeName = property.type?.prototype &amp;&amp; property.type?.name ? property.type.name : XElement.__getTypeName(property.type);
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Found unserializable &quot;<span class="hljs-subst">${path}</span>.type&quot; (<span class="hljs-subst">${typeName}</span>) but &quot;<span class="hljs-subst">${path}</span>.reflect&quot; is true.`</span>);
    }
    <span class="hljs-keyword">if</span> (compute &amp;&amp; !input) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Found &quot;<span class="hljs-subst">${path}</span>.compute&quot; without &quot;<span class="hljs-subst">${path}</span>.input&quot; (computed properties require input).`</span>);
    }
    <span class="hljs-keyword">if</span> (input &amp;&amp; !compute) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Found &quot;<span class="hljs-subst">${path}</span>.input&quot; without &quot;<span class="hljs-subst">${path}</span>.compute&quot; (computed properties require a compute callback).`</span>);
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Reflect</span>.has(property, <span class="hljs-string">&#x27;initial&#x27;</span>) &amp;&amp; compute) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Found &quot;<span class="hljs-subst">${path}</span>.initial&quot; and &quot;<span class="hljs-subst">${path}</span>.compute&quot; (computed properties cannot set an initial value).`</span>);
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Reflect</span>.has(property, <span class="hljs-string">&#x27;readOnly&#x27;</span>) &amp;&amp; compute) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Found &quot;<span class="hljs-subst">${path}</span>.readOnly&quot; and &quot;<span class="hljs-subst">${path}</span>.compute&quot; (computed properties cannot define read-only).`</span>);
    }
    <span class="hljs-keyword">if</span> (reflect &amp;&amp; internal) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Both &quot;<span class="hljs-subst">${path}</span>.reflect&quot; and &quot;<span class="hljs-subst">${path}</span>.internal&quot; are true (reflected properties cannot be internal).`</span>);
    }
    <span class="hljs-keyword">if</span> (internal &amp;&amp; readOnly) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Both &quot;<span class="hljs-subst">${path}</span>.internal&quot; and &quot;<span class="hljs-subst">${path}</span>.readOnly&quot; are true (read-only properties cannot be internal).`</span>);
    }
    <span class="hljs-keyword">if</span> (internal &amp;&amp; attribute) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Found &quot;<span class="hljs-subst">${path}</span>.attribute&quot; but &quot;<span class="hljs-subst">${path}</span>.internal&quot; is true (internal properties cannot have attributes).`</span>);
    }
  }

  <span class="hljs-keyword">static</span> __propertyIsCyclic(property, inputMap, seen = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()) {
    <span class="hljs-keyword">if</span> (inputMap.has(property)) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> input <span class="hljs-keyword">of</span> inputMap.get(property)) {
        <span class="hljs-keyword">const</span> nextSeen = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...seen, property]);
        <span class="hljs-keyword">if</span> (
          input === property ||
          seen.has(input) ||
          XElement.__propertyIsCyclic(input, inputMap, nextSeen)
        ) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
      }
    }
  }

  <span class="hljs-keyword">static</span> __validateListeners(<span class="hljs-keyword">constructor</span>, listeners, entries) {
    <span class="hljs-keyword">const</span> path = <span class="hljs-string">`<span class="hljs-subst">${constructor.name}</span>.listeners`</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [type, listener] <span class="hljs-keyword">of</span> entries) {
      <span class="hljs-keyword">if</span> (XElement.__typeIsWrong(<span class="hljs-built_in">Function</span>, listener)) {
        <span class="hljs-keyword">const</span> typeName = XElement.__getTypeName(listener);
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`<span class="hljs-subst">${path}</span>.<span class="hljs-subst">${type}</span> has unexpected value (expected Function, got <span class="hljs-subst">${typeName}</span>).`</span>);
      }
    }
  }

  <span class="hljs-keyword">static</span> __mutateProperty(<span class="hljs-keyword">constructor</span>, propertyMap, key, property) {
    property.key = key;
    property.attribute = property.attribute ?? XElement.__camelToKebab(key);
    property.input = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>((property.input ?? []).map(<span class="hljs-function"><span class="hljs-params">inputKey</span> =&gt;</span> propertyMap.get(inputKey)));
    property.output = property.output ?? <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> input <span class="hljs-keyword">of</span> property.input) {
      input.output = input.output ?? <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
      input.output.add(property);
    }
    XElement.__addPropertyInitial(<span class="hljs-keyword">constructor</span>, property);
    XElement.__addPropertyDefault(<span class="hljs-keyword">constructor</span>, property);
    XElement.__addPropertySync(<span class="hljs-keyword">constructor</span>, property);
    XElement.__addPropertyCompute(<span class="hljs-keyword">constructor</span>, property);
    XElement.__addPropertyReflect(<span class="hljs-keyword">constructor</span>, property);
    XElement.__addPropertyObserve(<span class="hljs-keyword">constructor</span>, property);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Wrapper to improve ergonomics of coalescing nullish, initial value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">static</span> __addPropertyInitial(<span class="hljs-keyword">constructor</span>, property) {</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Should take <code>value</code> in and spit the initial or value out.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Reflect</span>.has(property, <span class="hljs-string">&#x27;initial&#x27;</span>)) {
      <span class="hljs-keyword">const</span> initialValue = XElement.__typeIsWrong(<span class="hljs-built_in">Function</span>, property.initial)
        ? property.initial
        : property.initial.call(<span class="hljs-keyword">constructor</span>);
      const isFunction = XElement.__typeIsWrong(Function, initialValue) === false;
      property.initial = value =&gt; {
        <span class="hljs-keyword">return</span> value ?? (isFunction ? initialValue.call(<span class="hljs-keyword">constructor</span>) : initialValue);
      };
    } else {
      property.initial = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value;
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Wrapper to improve ergonomics of coalescing nullish, default value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">static</span> __addPropertyDefault(<span class="hljs-keyword">constructor</span>, property) {</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Should take <code>value</code> in and spit the default or value out.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Reflect</span>.has(property, <span class="hljs-string">&#x27;default&#x27;</span>)) {
      <span class="hljs-keyword">const</span> defaultValue = XElement.__typeIsWrong(<span class="hljs-built_in">Function</span>, property.default)
        ? property.default
        : property.default.call(<span class="hljs-keyword">constructor</span>);
      const isFunction = XElement.__typeIsWrong(Function, defaultValue) === false;
      property.default = value =&gt; {
        <span class="hljs-keyword">return</span> value ?? (isFunction ? defaultValue.call(<span class="hljs-keyword">constructor</span>) : defaultValue);
      };
    } else {
      property.default = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value;
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Wrapper to improve ergonomics of syncing attributes back to properties.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">static</span> __addPropertySync(<span class="hljs-keyword">constructor</span>, property) {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Reflect</span>.has(property, <span class="hljs-string">&#x27;type&#x27;</span>) &amp;&amp; XElement.__serializableTypes.has(property.type) === <span class="hljs-literal">false</span>) {
      property.sync = <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">const</span> path = <span class="hljs-string">`<span class="hljs-subst">${constructor.name}</span>.properties.<span class="hljs-subst">${property.key}</span>`</span>;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unexpected deserialization for &quot;<span class="hljs-subst">${path}</span>&quot; (cannot deserialize into <span class="hljs-subst">${property.type.name}</span>).`</span>);
      };
    } <span class="hljs-keyword">else</span> {
      property.sync = <span class="hljs-function">(<span class="hljs-params">host, value, oldValue</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> { initialized, reflecting } = XElement.__hosts.get(host);
        <span class="hljs-keyword">if</span> (reflecting === <span class="hljs-literal">false</span> &amp;&amp; initialized &amp;&amp; value !== oldValue) {
          <span class="hljs-keyword">const</span> deserialization = XElement.__deserializeProperty(host, property, value);
          host[property.key] = deserialization;
        }
      };
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Wrapper to centralize logic needed to perform reflection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">static</span> __addPropertyReflect(<span class="hljs-keyword">constructor</span>, property) {
    <span class="hljs-keyword">if</span> (property.reflect) {
      property.reflect = <span class="hljs-function"><span class="hljs-params">host</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> value = XElement.__getPropertyValue(host, property);
        <span class="hljs-keyword">const</span> serialization = XElement.__serializeProperty(host, property, value);
        <span class="hljs-keyword">const</span> hostInfo = XElement.__hosts.get(host);
        hostInfo.reflecting = <span class="hljs-literal">true</span>;
        serialization === <span class="hljs-literal">undefined</span>
          ? host.removeAttribute(property.attribute)
          : host.setAttribute(property.attribute, serialization);
        hostInfo.reflecting = <span class="hljs-literal">false</span>;
      };
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Wrapper to prevent repeated compute callbacks.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">static</span> __addPropertyCompute(<span class="hljs-keyword">constructor</span>, property) {
    <span class="hljs-keyword">const</span> { compute } = property;
    <span class="hljs-keyword">if</span> (compute) {
      property.compute = <span class="hljs-function"><span class="hljs-params">host</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> { computeMap, valueMap } = XElement.__hosts.get(host);
        <span class="hljs-keyword">const</span> saved = computeMap.get(property);
        <span class="hljs-keyword">if</span> (saved.valid === <span class="hljs-literal">false</span>) {
          <span class="hljs-keyword">const</span> args = [];
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> input <span class="hljs-keyword">of</span> property.input) {
            args.push(XElement.__getPropertyValue(host, input));
          }
          <span class="hljs-keyword">if</span> (saved.args === <span class="hljs-literal">undefined</span> || args.some(<span class="hljs-function">(<span class="hljs-params">arg, index</span>) =&gt;</span> arg !== saved.args[index])) {
            <span class="hljs-keyword">const</span> value = property.default(compute.call(<span class="hljs-keyword">constructor</span>, ...args));
            XElement.__validatePropertyValue(host, property, value);
            valueMap.set(property, value);
            saved.args = args;
          }
          saved.valid = true;
        }
        return valueMap.get(property);
      };
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Wrapper to provide last value to observe callbacks.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">static</span> __addPropertyObserve(<span class="hljs-keyword">constructor</span>, property) {
    <span class="hljs-keyword">const</span> { observe } = property;
    <span class="hljs-keyword">if</span> (observe) {
      property.observe = <span class="hljs-function"><span class="hljs-params">host</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> saved = XElement.__hosts.get(host).observeMap.get(property);
        <span class="hljs-keyword">const</span> value = XElement.__getPropertyValue(host, property);
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.is(value, saved.value) === <span class="hljs-literal">false</span>) {
          observe.call(<span class="hljs-keyword">constructor</span>, host, value, saved.value);
        }
        saved.value = value;
      };
    }
  }

  static __constructHost(host) {
    <span class="hljs-keyword">const</span> invalidProperties = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>The weak map prevents memory leaks. E.g., adding anonymous listeners.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">const</span> listenerMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();
    <span class="hljs-keyword">const</span> valueMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">const</span> renderRoot = host.constructor.createRenderRoot(host);
    <span class="hljs-keyword">if</span> (!renderRoot || renderRoot !== host &amp;&amp; renderRoot !== host.shadowRoot) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Unexpected render root returned. Expected &quot;host&quot; or &quot;host.shadowRoot&quot;.&#x27;</span>);
    }
    <span class="hljs-keyword">const</span> template = host.constructor.template(html, {
      asyncAppend, asyncReplace, cache, classMap, directive, guard, html,
      ifDefined, live, repeat, styleMap, svg, templateContent, unsafeHTML,
      unsafeSVG, until,
    });
    <span class="hljs-keyword">const</span> properties = XElement.__createProperties(host);
    <span class="hljs-keyword">const</span> internal = XElement.__createInternal(host);
    <span class="hljs-keyword">const</span> computeMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">const</span> observeMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
    <span class="hljs-keyword">const</span> { propertyMap } = XElement.__constructors.get(host.constructor);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> property <span class="hljs-keyword">of</span> propertyMap.values()) {
      <span class="hljs-keyword">if</span> (property.compute) {
        computeMap.set(property, { <span class="hljs-attr">valid</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">args</span>: <span class="hljs-literal">undefined</span> });
      }
      <span class="hljs-keyword">if</span> (property.observe) {
        observeMap.set(property, { <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span> });
      }
    }
    XElement.__hosts.set(host, {
      <span class="hljs-attr">initialized</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">reflecting</span>: <span class="hljs-literal">false</span>, invalidProperties, listenerMap,
      renderRoot, template, properties, internal, computeMap, observeMap,
      valueMap,
    });
  }

  <span class="hljs-keyword">static</span> __createInternal(host) {
    <span class="hljs-keyword">const</span> { propertyMap, internalPropertyMap, internalTarget } =  XElement.__constructors.get(host.constructor);</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Everything but “get”, “set”, “has”, and “ownKeys” are considered invalid.
Note that impossible traps like “apply” or “construct” are not guarded.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">const</span> invalid = <span class="hljs-function">() =&gt;</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Invalid use of internal proxy.&#x27;</span>); };
    <span class="hljs-keyword">const</span> get = <span class="hljs-function">(<span class="hljs-params">target, key</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> internalProperty = internalPropertyMap.get(key);
      <span class="hljs-keyword">if</span> (internalProperty?.internal) {
        <span class="hljs-keyword">return</span> XElement.__getPropertyValue(host, internalProperty);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">const</span> path = <span class="hljs-string">`<span class="hljs-subst">${host.constructor.name}</span>.properties.<span class="hljs-subst">${key}</span>`</span>;
        <span class="hljs-keyword">const</span> property = propertyMap.get(key);
        <span class="hljs-keyword">if</span> (property === <span class="hljs-literal">undefined</span>) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Property &quot;<span class="hljs-subst">${path}</span>&quot; does not exist.`</span>);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Property &quot;<span class="hljs-subst">${path}</span>&quot; is publicly available (use normal getter).`</span>);
        }
      }
    };
    <span class="hljs-keyword">const</span> set = <span class="hljs-function">(<span class="hljs-params">target, key, value</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> internalProperty = internalPropertyMap.get(key);
      <span class="hljs-keyword">if</span> (internalProperty &amp;&amp; <span class="hljs-built_in">Reflect</span>.has(internalProperty, <span class="hljs-string">&#x27;compute&#x27;</span>) === <span class="hljs-literal">false</span>) {
        XElement.__setPropertyValue(host, internalProperty, value);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">const</span> path = <span class="hljs-string">`<span class="hljs-subst">${host.constructor.name}</span>.properties.<span class="hljs-subst">${key}</span>`</span>;
        <span class="hljs-keyword">const</span> property = propertyMap.get(key);
        <span class="hljs-keyword">if</span> (property === <span class="hljs-literal">undefined</span>) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Property &quot;<span class="hljs-subst">${path}</span>&quot; does not exist.`</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (property.compute) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Property &quot;<span class="hljs-subst">${path}</span>&quot; is computed (computed properties are read-only).`</span>);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Property &quot;<span class="hljs-subst">${path}</span>&quot; is publicly available (use normal setter).`</span>);
        }
      }
    };
    <span class="hljs-keyword">const</span> has = <span class="hljs-function">(<span class="hljs-params">target, key</span>) =&gt;</span> internalPropertyMap.has(key);
    <span class="hljs-keyword">const</span> ownKeys = <span class="hljs-function">() =&gt;</span> [...internalPropertyMap.keys()];
    <span class="hljs-keyword">const</span> handler = {
      <span class="hljs-attr">defineProperty</span>: invalid, <span class="hljs-attr">deleteProperty</span>: invalid, get,
      <span class="hljs-attr">getOwnPropertyDescriptor</span>: invalid, <span class="hljs-attr">getPrototypeOf</span>: invalid, has,
      <span class="hljs-attr">isExtensible</span>: invalid, ownKeys, <span class="hljs-attr">preventExtensions</span>: invalid,
      set, <span class="hljs-attr">setPrototypeOf</span>: invalid,
    };
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(internalTarget, handler);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Only available in template callback. Provides getter for all properties.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">static</span> __createProperties(host) {
    <span class="hljs-keyword">const</span> { propertyMap, propertiesTarget } =  XElement.__constructors.get(host.constructor);</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Everything but “get”, “set”, “has”, and “ownKeys” are considered invalid.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">const</span> invalid = <span class="hljs-function">() =&gt;</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Invalid use of properties proxy.&#x27;</span>); };
    <span class="hljs-keyword">const</span> get = <span class="hljs-function">(<span class="hljs-params">target, key</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (propertyMap.has(key)) {
        <span class="hljs-keyword">return</span> XElement.__getPropertyValue(host, propertyMap.get(key));
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">const</span> path = <span class="hljs-string">`<span class="hljs-subst">${host.constructor.name}</span>.properties.<span class="hljs-subst">${key}</span>`</span>;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Property &quot;<span class="hljs-subst">${path}</span>&quot; does not exist.`</span>);
      }
    };
    <span class="hljs-keyword">const</span> set = <span class="hljs-function">(<span class="hljs-params">target, key</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> path = <span class="hljs-string">`<span class="hljs-subst">${host.constructor.name}</span>.properties.<span class="hljs-subst">${key}</span>`</span>;
      <span class="hljs-keyword">if</span> (propertyMap.has(key)) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Cannot set &quot;<span class="hljs-subst">${path}</span>&quot; via &quot;properties&quot;.`</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Property &quot;<span class="hljs-subst">${path}</span>&quot; does not exist.`</span>);
      }
    };
    <span class="hljs-keyword">const</span> has = <span class="hljs-function">(<span class="hljs-params">target, key</span>) =&gt;</span> propertyMap.has(key);
    <span class="hljs-keyword">const</span> ownKeys = <span class="hljs-function">() =&gt;</span> [...propertyMap.keys()];
    <span class="hljs-keyword">const</span> handler = {
      <span class="hljs-attr">defineProperty</span>: invalid, <span class="hljs-attr">deleteProperty</span>: invalid, get,
      <span class="hljs-attr">getOwnPropertyDescriptor</span>: invalid, <span class="hljs-attr">getPrototypeOf</span>: invalid, has,
      <span class="hljs-attr">isExtensible</span>: invalid, ownKeys, <span class="hljs-attr">preventExtensions</span>: invalid, set,
      <span class="hljs-attr">setPrototypeOf</span>: invalid,
    };
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(propertiesTarget, handler);
  }

  <span class="hljs-keyword">static</span> __initializeHost(host) {
    <span class="hljs-keyword">const</span> hostInfo = XElement.__hosts.get(host);
    <span class="hljs-keyword">const</span> { initialized, invalidProperties } = hostInfo;
    <span class="hljs-keyword">if</span> (initialized === <span class="hljs-literal">false</span>) {
      XElement.__upgradeOwnProperties(host);</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Only reflect attributes when the element is connected.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">const</span> { propertyMap } = XElement.__constructors.get(host.constructor);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> property <span class="hljs-keyword">of</span> propertyMap.values()) {
        <span class="hljs-keyword">const</span> { value, found } = XElement.__getPreUpgradePropertyValue(host, property);
        XElement.__initializeProperty(host, property);
        <span class="hljs-keyword">if</span> (found) {
          host[property.key] = property.default(property.initial(value));
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!property.compute) {</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Set to a nullish value so that it coalesces to the default.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          XElement.__setPropertyValue(host, property, property.default(property.initial()));
        }
        invalidProperties.add(property);
      }
      hostInfo.initialized = <span class="hljs-literal">true</span>;
      XElement.__updateHost(host);
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Prevent shadowing from properties added to element instance pre-upgrade.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">static</span> __upgradeOwnProperties(host) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> <span class="hljs-built_in">Reflect</span>.ownKeys(host)) {
      <span class="hljs-keyword">const</span> value = <span class="hljs-built_in">Reflect</span>.get(host, key);
      <span class="hljs-built_in">Reflect</span>.deleteProperty(host, key);
      <span class="hljs-built_in">Reflect</span>.set(host, key, value);
    }
  }

  <span class="hljs-keyword">static</span> __getPreUpgradePropertyValue(host, property) {</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Process possible sources of initial state, with this priority:</p>
<ol>
<li>imperative, e.g. <code>element.prop = &#39;value&#39;;</code></li>
<li>declarative, e.g. <code>&lt;element prop=&quot;value&quot;&gt;&lt;/element&gt;</code></li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">const</span> { key, attribute } = property;
    <span class="hljs-keyword">let</span> value;
    <span class="hljs-keyword">let</span> found = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Reflect</span>.has(host, key)) {
      value = host[key];
      found = <span class="hljs-literal">true</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (host.hasAttribute(attribute)) {
      <span class="hljs-keyword">const</span> attributeValue = host.getAttribute(attribute);
      value = XElement.__deserializeProperty(host, property, attributeValue);
      found = <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">return</span> { value, found };
  }

  <span class="hljs-keyword">static</span> __initializeProperty(host, property) {
    <span class="hljs-keyword">const</span> { key, compute, readOnly, internal } = property;
    <span class="hljs-keyword">const</span> path = <span class="hljs-string">`<span class="hljs-subst">${host.constructor.name}</span>.properties.<span class="hljs-subst">${key}</span>`</span>;
    <span class="hljs-keyword">const</span> get = internal
      ? <span class="hljs-function">() =&gt;</span> { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Property &quot;<span class="hljs-subst">${path}</span>&quot; is internal (internal.<span class="hljs-subst">${key}</span>).`</span>); }
      : <span class="hljs-function">() =&gt;</span> XElement.__getPropertyValue(host, property);
    <span class="hljs-keyword">const</span> set = compute || readOnly || internal
      ? <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-keyword">if</span> (compute &amp;&amp; !internal) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Property &quot;<span class="hljs-subst">${path}</span>&quot; is computed (computed properties are read-only).`</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (readOnly) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Property &quot;<span class="hljs-subst">${path}</span>&quot; is read-only (internal.<span class="hljs-subst">${key}</span>).`</span>);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Property &quot;<span class="hljs-subst">${path}</span>&quot; is internal (internal.<span class="hljs-subst">${key}</span>).`</span>);
        }
      }
      : <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> XElement.__setPropertyValue(host, property, value);
    <span class="hljs-keyword">const</span> enumerable = !internal;
    <span class="hljs-built_in">Reflect</span>.deleteProperty(host, key);
    <span class="hljs-built_in">Reflect</span>.defineProperty(host, key, { get, set, enumerable });
  }

  <span class="hljs-keyword">static</span> __addListener(host, element, type, callback, options) {
    callback = XElement.__getListener(host, callback);
    element.addEventListener(type, callback, options);
  }

  <span class="hljs-keyword">static</span> __addListeners(host) {
    <span class="hljs-keyword">const</span> { listenerMap } = XElement.__constructors.get(host.constructor);
    <span class="hljs-keyword">const</span> { renderRoot } = XElement.__hosts.get(host);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [type, listener] <span class="hljs-keyword">of</span> listenerMap) {
      XElement.__addListener(host, renderRoot, type, listener);
    }
  }

  <span class="hljs-keyword">static</span> __removeListener(host, element, type, callback, options) {
    callback = XElement.__getListener(host, callback);
    element.removeEventListener(type, callback, options);
  }

  <span class="hljs-keyword">static</span> __removeListeners(host) {
    <span class="hljs-keyword">const</span> { listenerMap } = XElement.__constructors.get(host.constructor);
    <span class="hljs-keyword">const</span> { renderRoot } = XElement.__hosts.get(host);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [type, listener] <span class="hljs-keyword">of</span> listenerMap) {
      XElement.__removeListener(host, renderRoot, type, listener);
    }
  }

  <span class="hljs-keyword">static</span> __getListener(host, listener) {
    <span class="hljs-keyword">const</span> { listenerMap } = XElement.__hosts.get(host);
    <span class="hljs-keyword">if</span> (listenerMap.has(listener) === <span class="hljs-literal">false</span>) {
      listenerMap.set(listener, listener.bind(host.constructor, host));
    }
    <span class="hljs-keyword">return</span> listenerMap.get(listener);
  }

  <span class="hljs-keyword">static</span> __updateHost(host) {</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Order of operations: compute, reflect, render, then observe.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">const</span> { invalidProperties } = XElement.__hosts.get(host);
    <span class="hljs-keyword">const</span> invalidPropertiesCopy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(invalidProperties);
    invalidProperties.clear();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> property <span class="hljs-keyword">of</span> invalidPropertiesCopy) {
      property.reflect?.(host);
    }
    host.render();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> property <span class="hljs-keyword">of</span> invalidPropertiesCopy) {
      property.observe?.(host);
    }
  }

  <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> __invalidateProperty(host, property) {
    <span class="hljs-keyword">const</span> { initialized, invalidProperties, computeMap } = XElement.__hosts.get(host);
    <span class="hljs-keyword">if</span> (initialized) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> output <span class="hljs-keyword">of</span> property.output) {
        XElement.__invalidateProperty(host, output);
      }
      <span class="hljs-keyword">const</span> queueUpdate = invalidProperties.size === <span class="hljs-number">0</span>;
      invalidProperties.add(property);
      <span class="hljs-keyword">if</span> (property.compute) {
        computeMap.get(property).valid = <span class="hljs-literal">false</span>;
      }
      <span class="hljs-keyword">if</span> (queueUpdate) {</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>Queue a microtask. Allows multiple, synchronous changes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve();
        XElement.__updateHost(host);
      }
    }
  }

  <span class="hljs-keyword">static</span> __getPropertyValue(host, property) {
    <span class="hljs-keyword">const</span> { valueMap } = XElement.__hosts.get(host);
    <span class="hljs-keyword">return</span> property.compute?.(host) ?? valueMap.get(property);
  }

  <span class="hljs-keyword">static</span> __validatePropertyValue(host, property, value) {
    <span class="hljs-keyword">if</span> (property.type &amp;&amp; XElement.__notNullish(value)) {
      <span class="hljs-keyword">if</span> (XElement.__typeIsWrong(property.type, value)) {
        <span class="hljs-keyword">const</span> path = <span class="hljs-string">`<span class="hljs-subst">${host.constructor.name}</span>.properties.<span class="hljs-subst">${property.key}</span>`</span>;
        <span class="hljs-keyword">const</span> typeName = XElement.__getTypeName(value);
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unexpected value for &quot;<span class="hljs-subst">${path}</span>&quot; (expected <span class="hljs-subst">${property.type.name}</span>, got <span class="hljs-subst">${typeName}</span>).`</span>);
      }
    }
  }

  <span class="hljs-keyword">static</span> __setPropertyValue(host, property, value) {
    <span class="hljs-keyword">const</span> { valueMap } = XElement.__hosts.get(host);
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.is(value, valueMap.get(property)) === <span class="hljs-literal">false</span>) {
      value = property.default(value);
      XElement.__validatePropertyValue(host, property, value);
      valueMap.set(property, value);
      XElement.__invalidateProperty(host, property);
    }
  }

  <span class="hljs-keyword">static</span> __serializeProperty(host, property, value) {
    <span class="hljs-keyword">if</span> (XElement.__notNullish(value)) {
      <span class="hljs-keyword">if</span> (property.type === <span class="hljs-built_in">Boolean</span>) {
        <span class="hljs-keyword">return</span> value ? <span class="hljs-string">&#x27;&#x27;</span> : <span class="hljs-literal">undefined</span>;
      }
      <span class="hljs-keyword">return</span> value.toString();
    }
  }

  <span class="hljs-keyword">static</span> __deserializeProperty(host, property, value) {
    <span class="hljs-keyword">if</span> (property.type) {
      <span class="hljs-keyword">if</span> (property.type === <span class="hljs-built_in">Boolean</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>Per HTML spec, every value other than null is considered true.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> value !== <span class="hljs-literal">null</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Null as an attribute is really “undefined” as a property.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>Coerce type as needed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> property.type(value);
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> value;
    }
  }

  <span class="hljs-keyword">static</span> __getTypeName(value) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(value).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>);
  }

  <span class="hljs-keyword">static</span> __notNullish(value) {
    <span class="hljs-keyword">return</span> value !== <span class="hljs-literal">undefined</span> &amp;&amp; value !== <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">static</span> __typeIsWrong(type, value) {</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>Because <code>instanceof</code> fails on primitives (<code>&#39;&#39; instanceof String === false</code>)
and <code>Object.prototype.toString</code> cannot handle inheritance, we use both.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">return</span> (
      XElement.__notNullish(value) === <span class="hljs-literal">false</span> ||
      (!(value <span class="hljs-keyword">instanceof</span> type) &amp;&amp; XElement.__getTypeName(value) !== type.name)
    );
  }

  <span class="hljs-keyword">static</span> __camelToKebab(camel) {
    <span class="hljs-keyword">if</span> (XElement.__caseMap.has(camel) === <span class="hljs-literal">false</span>) {
      XElement.__caseMap.set(camel, camel.replace(<span class="hljs-regexp">/([A-Z])/g</span>, <span class="hljs-string">&#x27;-$1&#x27;</span>).toLowerCase());
    }
    <span class="hljs-keyword">return</span> XElement.__caseMap.get(camel);
  }
}</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>TODO: define as private class fields inside the constructor when supported.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>XElement.__constructors = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();
XElement.__hosts = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();
XElement.__propertyKeys = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&#x27;type&#x27;</span>, <span class="hljs-string">&#x27;attribute&#x27;</span>, <span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-string">&#x27;compute&#x27;</span>, <span class="hljs-string">&#x27;observe&#x27;</span>, <span class="hljs-string">&#x27;reflect&#x27;</span>, <span class="hljs-string">&#x27;internal&#x27;</span>, <span class="hljs-string">&#x27;readOnly&#x27;</span>, <span class="hljs-string">&#x27;initial&#x27;</span>, <span class="hljs-string">&#x27;default&#x27;</span>]);
XElement.__serializableTypes = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-built_in">Boolean</span>, <span class="hljs-built_in">String</span>, <span class="hljs-built_in">Number</span>]);
XElement.__caseMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();

<span class="hljs-keyword">const</span> X_ELEMENT_INTERFACE = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(<span class="hljs-built_in">Object</span>.getOwnPropertyNames(XElement.prototype));
<span class="hljs-keyword">const</span> INHERITED_INTERFACE = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
<span class="hljs-keyword">let</span> prototype = HTMLElement.prototype;
<span class="hljs-keyword">while</span> (prototype) {
  <span class="hljs-built_in">Object</span>.getOwnPropertyNames(prototype).forEach(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> INHERITED_INTERFACE.add(name));
  prototype = <span class="hljs-built_in">Object</span>.getPrototypeOf(prototype);
}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
